#!/usr/bin/env bash
set -Eeuo pipefail

# ========= Neomnia ‚Äî Azure mini-setup (prompts d'abord) =========

RED="\033[31m"; GREEN="\033[32m"; YELLOW="\033[33m"; CYAN="\033[36m"; RESET="\033[0m"
LOGFILE="/var/log/neomnia-setup.log"; mkdir -p "$(dirname "$LOGFILE")" 2>/dev/null || true; touch "$LOGFILE" 2>/dev/null || true
log(){ echo -e "${CYAN}[Neomnia]${RESET} $*"; echo "[$(date '+%F %T')] $*" >>"$LOGFILE"; }
ok(){ log "${GREEN}‚úî${RESET} $*"; }
warn(){ log "${YELLOW}‚ö†${RESET} $*"; }
err(){ log "${RED}‚úñ${RESET} $*"; }
trap 'err "Une erreur est survenue (ligne ${BASH_LINENO[0]}). Consulter $LOGFILE."' ERR

# --- helpers I/O (marche avec `curl | sudo bash`)
INPUT_TTY="/dev/tty"; have_tty=false; { [ -t 0 ] || [ -r "$INPUT_TTY" ]; } && have_tty=true
normalize(){ local s="${1%$'\r'}"; s="${s#"${s%%[![:space:]]*}"}"; s="${s%"${s##*[![:space:]]}"}"; printf '%s' "$s"; }
ask(){ local p="$1" v=""; read -rp "$p" v <"$INPUT_TTY"; printf '%s' "$(normalize "$v")"; }
ask_secret(){ local p="$1" v=""; read -srp "$p" v <"$INPUT_TTY"; echo; printf '%s' "$(normalize "$v")"; }

# --- PROMPTS (ou variables d'env), AVANT toute action
: "${GROUP_NAME:=}"; : "${GITHUB_TOKEN:=${GH_TOKEN:-}}"

if [[ -z "${GROUP_NAME// }" ]]; then
  $have_tty || { err "Aucun TTY : d√©finis GROUP_NAME en variable d'environnement."; exit 1; }
  GROUP_NAME="$(ask 'üëâ Nom du groupe √† cr√©er : ')" || true
  [[ -n "${GROUP_NAME// }" ]] || { err "GROUP_NAME requis."; exit 1; }
fi

if [[ -z "${GITHUB_TOKEN// }" ]]; then
  $have_tty || { err "Aucun TTY : d√©finis GITHUB_TOKEN (ou GH_TOKEN) en env."; exit 1; }
  GITHUB_TOKEN="$(ask_secret 'üëâ Cl√© API GitHub (masqu√©e) : ')" || true
  [[ -n "${GITHUB_TOKEN// }" ]] || { err "Token vide."; exit 1; }
fi

# Export des deux noms pour contenter tout le monde (wrapper inclus)
export GITHUB_TOKEN
export GH_TOKEN="$GITHUB_TOKEN"

# Optionnel : demander des d√©p√¥ts pour le wrapper (sinon on saute)
REPOS=""
if $have_tty; then
  REPOS="$(ask 'üëâ D√©p√¥ts pour git-wrapper (owner/repo, s√©par√©s par espaces) ‚Äî laisser vide pour passer : ')" || true
fi

# --- PR√âREQUIS MINIMAUX
[[ $EUID -eq 0 ]] || { err "Ex√©cuter en root (sudo)."; exit 1; }
need=()
command -v curl >/dev/null 2>&1 || need+=("curl")
command -v jq   >/dev/null 2>&1 || need+=("jq")
command -v git  >/dev/null 2>&1 || need+=("git")
command -v gh   >/dev/null 2>&1 || need+=("gh")
command -v setfacl >/dev/null 2>&1 || need+=("acl")   # setfacl est dans 'acl' (Ubuntu)
if ((${#need[@]})); then
  log "Installation des d√©pendances: ${need[*]}"
  apt-get update -y >/dev/null 2>&1 || true
  apt-get install -y "${need[@]}" >/dev/null
  ok "D√©pendances install√©es: ${need[*]}"
else
  ok "D√©pendances d√©j√† pr√©sentes."
fi

# --- VALIDATION TOKEN (sans gh auth login, pas de device flow)
log "Validation GitHub via token‚Ä¶"
if ! ( GITHUB_TOKEN="$GITHUB_TOKEN" gh api user >/dev/null 2>&1 || curl -fsS -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/user >/dev/null 2>&1 ); then
  err "Token GitHub invalide (scopes ?)."
  exit 1
fi
ok "Token GitHub valid√©."

# --- GROUPE + ajout de l'utilisateur courant
AZ_USER="${SUDO_USER:-$(whoami)}"
log "Groupe cible: ${GROUP_NAME}"
if getent group "$GROUP_NAME" >/dev/null; then
  warn "Groupe ${GROUP_NAME} d√©j√† existant."
else
  groupadd "$GROUP_NAME"
  ok "Groupe ${GROUP_NAME} cr√©√©."
fi
if [[ -n "$AZ_USER" ]]; then
  usermod -a -G "$GROUP_NAME" "$AZ_USER"
  ok "Utilisateur ${AZ_USER} ajout√© √† ${GROUP_NAME}."
fi

# --- ACL /opt
mkdir -p /opt
chown -R root:"$GROUP_NAME" /opt
chmod -R 2775 /opt
setfacl -R  -m g:"$GROUP_NAME":rwx /opt
setfacl -dR -m g:"$GROUP_NAME":rwx /opt
ok "ACL appliqu√©es sur /opt pour ${GROUP_NAME}."

# --- GitHub CLI: ne surtout pas lancer 'gh auth login'
ok "gh pr√™t (pas d'auth interactive)."

# --- git-wrapper.sh (SEULEMENT si des d√©p√¥ts ont √©t√© fournis)
if [[ -n "${REPOS// }" ]]; then
  GIT_WRAPPER_URL="https://raw.githubusercontent.com/charlesvdd/administrator-neomnia/api-key-github/git-wrapper.sh"
  GIT_WRAPPER_PATH="/usr/local/bin/git-wrapper.sh"
  log "T√©l√©chargement de git-wrapper.sh"
  curl -fsSL "$GIT_WRAPPER_URL" -o "$GIT_WRAPPER_PATH"
  chmod +x "$GIT_WRAPPER_PATH"
  log "Ex√©cution de git-wrapper.sh‚Ä¶"
  # Astuce : on peut passer des flags si besoin, ex: --release --bump patch
  ( set +u +x; GITHUB_TOKEN="$GITHUB_TOKEN" GH_TOKEN="$GITHUB_TOKEN" bash "$GIT_WRAPPER_PATH" $REPOS ) >>"$LOGFILE" 2>&1 || {
    err "git-wrapper.sh a √©chou√© (voir $LOGFILE)"; exit 1; }
  ok "git-wrapper.sh ex√©cut√©."
else
  warn "Aucun d√©p√¥t renseign√© ‚Äî git-wrapper non ex√©cut√©."
fi

ok "Termin√©. Groupe=${GROUP_NAME} | User=${AZ_USER} | Log=${LOGFILE}"
